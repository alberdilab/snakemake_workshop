# Advanced rule parameters

## Params

**params** are a convenient way to pass options or constants to your command. They are not files (unlike input/output) and not automatically tracked by Snakemake (so changes don’t normally trigger re-runs).

```{sh eval=FALSE}
rule align_reads:
    input:
        reads="data/sample.fastq.gz",
        ref="ref/genome.fasta"
    output:
        "results/sample.bam"
    params:
        threads=4,
        extra="--very-sensitive"
    shell:
        "bowtie2 -x {input.ref} -U {input.reads} {params.extra} "
        "-p {params.threads} | samtools view -bS - > {output}"
```

- `params.threads` and `params.extra` are just strings/numbers you defined.
- They expand like `{params.threads}` inside the shell:.

## Threads

**threads** declares how many CPU cores a rule can use. Snakemake uses this information to schedule jobs across available cores when you run with >1 `-c/--cores`. **Unlike params, threads is resource-aware: Snakemake respects it when deciding how many jobs to run in parallel.**

```{sh eval=FALSE}
rule sort_bam:
    input:
        "results/sample.bam"
    output:
        "results/sample.sorted.bam"
    threads: 4
    shell:
        "samtools sort -@ {threads} -o {output} {input}"
```

- `threads: 4` tells Snakemake this job needs 4 cores.
- Inside shell:, you expand {threads} (not {params.threads}!).
- If you launch Snakemake with snakemake `--cores 8`, Snakemake can only run two of these jobs at once (because each consumes 4 cores).

## Resources

**resources** declare arbitrary, countable things a rule needs to run (memory, GPUs, disk, time, etc.). Unlike params, Snakemake tracks them globally (like threads), so scheduling respects resource limits.

```{sh eval=FALSE}
rule variant_calling:
    input:
        "results/sample.sorted.bam"
    output:
        "results/sample.vcf"
    threads: 8
    resources:
        mem_mb=16000,
        runtime=10
    shell:
        "freebayes -f ref/genome.fasta {input} > {output}"
```

- `resources: mem_mb=16000` indicates that the job needs 16 GB RAM.
- `resources: runtime=10` indicates that the job must be done within 10 minutes.
- Snakemake will schedule jobs so the total memory use never exceeds the limit you set with --resources.

## Attempts

Some jobs fail occasionally for reasons outside your workflow. `attempts` lets you tell Snakemake: “If this rule fails, try again up to N times before stopping”. For example, if a rule is declared to download a file from the internet and the connection fails, snakemake will try up to three times to accomplish the task. The number of attempts can be declared for each rule:

```{sh eval=FALSE}
rule variant_calling:
    input:
        "results/sample.sorted.bam"
    output:
        "results/sample.vcf"
    resources:
        mem_mb=16000,
        runtime=10
    attempts: 3
    shell:
        "freebayes -f ref/genome.fasta {input} > {output}"
```

Or a global number of attempts can be defined using the flag --retries.

```{sh eval=FALSE}
snakemake --retries 3
```

## Dynamic resources

When using Snakemake on an HPC with a queuing system, job failures often come from insufficient resources. To better address this issue,  Snakemake can adjust resources dynamically on each try by specifying rules for scaling.

```{sh eval=FALSE}
rule variant_calling:
    input:
        "results/sample.sorted.bam"
    output:
        "results/sample.vcf"
    threads: 8
    attempts: 3
    resources:
        mem_mb=lambda wildcards, attempt: 4000 * attempt,
        runtime=lambda wildcard, sattempt: 10 * attempt
    shell:
        "freebayes -f ref/genome.fasta {input} > {output}"
```

In the above example:

- First attempt: 4000 Mb of memory and 10 minutes
- Second attempt: 8000 Mb of memory and 20 minutes
- Third attempt: 12000 Mb of memory and 30 minutes

The scaling can also be exponential using the following function:

```{sh eval=FALSE}
rule variant_calling:
    input:
        "results/sample.sorted.bam"
    output:
        "results/sample.vcf"
    threads: 8
    attempts: 3
    resources:
        mem_mb=lambda wildcards, attempt: 4000 * 2 ** (attempt - 1),
        runtime=lambda wildcard, attempt: 10 * 2 ** (attempt - 1)
    shell:
        "freebayes -f ref/genome.fasta {input} > {output}"
```

In the new example, the resources will double in every attempt:

- First attempt: 4000*2^0 = 4000 Mb of memory and 10 minutes
- Second attempt: 4000*2^1 = 8000 Mb of memory and 20 minutes
- Third attempt: 4000*2^2 = 16000 Mb of memory and 40 minutes

However, the required resources can vary significantly within project: some input files might be 10 Mb, while others 100 Mb, requiring many more resources. The `input.size_mb` options allows for calculating the resources based on the size of the input files:

```{sh eval=FALSE}
rule variant_calling:
    input:
        "results/sample.sorted.bam"
    output:
        "results/sample.vcf"
    threads: 8
    attempts: 3
    resources:
        mem_mb=lambda wildcards, input, attempt: max(64*1024, int(input.size_mb * 10) * 2 ** (attempt - 1)),
        runtime=lambda wildcards, input, attempt: max(15, int(input.size_mb / 50) * 2 ** (attempt - 1))
    shell:
        "freebayes -f ref/genome.fasta {input} > {output}"
```

When defining such dynamic resources, it's not uncommon to require resources that are two small or so big that cannot be satisfied. The functions max() and min() enable setting minimum and maximum values within the resources can fluctuate.

```{sh eval=FALSE}
rule variant_calling:
    input:
        "results/sample.sorted.bam"
    output:
        "results/sample.vcf"
    threads: 8
    attempts: 3
    resources:
        mem_mb=lambda wildcards, input, attempt: max(64*1024, int(input.size_mb * 10) * 2 ** (attempt - 1)),
        runtime=lambda wildcards, input, attempt: min(1440, int(input.size_mb / 50) * 2 ** (attempt - 1))
    shell:
        "freebayes -f ref/genome.fasta {input} > {output}"
```

In the above example, the minimum amount of memory is set to 64 Gb. If the dynamic calculation is below that number, 64 Gb will be used instead. The maximum amount of time is set to 1440 minutes (a day). If the dynamic calculation exceds that number, the minimum value will be used, that is 1440.

## Exercise 3


