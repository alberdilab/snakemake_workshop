# Advanced rule parameters

## Params

**params** are a convenient way to pass options or constants to your command. They are not files (unlike input/output) and not automatically tracked by Snakemake (so changes donâ€™t normally trigger re-runs).

```{sh eval=FALSE}
rule align_reads:
    input:
        reads="data/sample.fastq.gz",
        ref="ref/genome.fasta"
    output:
        "results/sample.bam"
    params:
        threads=4,
        extra="--very-sensitive"
    shell:
        "bowtie2 -x {input.ref} -U {input.reads} {params.extra} "
        "-p {params.threads} | samtools view -bS - > {output}"
```

- `params.threads` and `params.extra` are just strings/numbers you defined.
- They expand like `{params.threads}` inside the shell:.

## Threads

**threads** declares how many CPU cores a rule can use. Snakemake uses this information to schedule jobs across available cores when you run with >1 `-c/--cores`. **Unlike params, threads is resource-aware: Snakemake respects it when deciding how many jobs to run in parallel.**

```{sh eval=FALSE}
rule sort_bam:
    input:
        "results/sample.bam"
    output:
        "results/sample.sorted.bam"
    threads: 4
    shell:
        "samtools sort -@ {threads} -o {output} {input}"
```

- `threads: 4` tells Snakemake this job needs 4 cores.
- Inside shell:, you expand {threads} (not {params.threads}!).
- If you launch Snakemake with snakemake `--cores 8`, Snakemake can only run two of these jobs at once (because each consumes 4 cores).

## Advanced inputs

### Expansions

Use `expand()` to build input lists for the all rule or aggregations.

```{sh eval=FALSE}
SAMPLES = ["S1", "S2", "S3"]

rule all:
    input:
        expand("qc/{sample}_fastqc.html", sample=SAMPLES)
```

The above code results in:

```{sh eval=FALSE}
rule all:
    input:
        "qc/S1_fastqc.html",
        "qc/S2_fastqc.html",
        "qc/S3_fastqc.html"
```

### Pattern-building helpers

Use `glob_wildcards` to discover samples containing a certain pattern:

```{sh eval=FALSE}
from snakemake.io import glob_wildcards
SAMPLES = glob_wildcards("reads/{sample}.fastq.gz").sample

rule all:
    input:
        expand("qc/{sample}_fastqc.html", sample=SAMPLES)
```

Get a list of file names in the directory `reads` that end with `_1.fq.gz`:

```{sh eval=FALSE}
from pathlib import Path
SAMPLES = sorted({f.stem.rsplit("_", 1)[0] for f in Path("reads").glob("*_1.fq.gz")})

rule all:
    input:
        expand("results/{sample}.tsv", sample=SAMPLES)
```

### Wildcards

```{sh eval=FALSE}
rule align:
    input:
        lambda wc: [f"reads/{wc.sample}_R1.fastq.gz",
                    f"reads/{wc.sample}_R2.fastq.gz"]
    output:
        "results/{sample}.bam"
```

## Exercise 3

In the directory `exercise3`, you will find a snakemake worflow  that requires you to use wildcards. Note this time the workflow requires the use of conda environments, so make sure you launch snakemake using:

```{sh eval=FALSE}
snakemake --use-conda
```

Try to fix it to get the output file `results/multiqc/report.html`.

<!--
- Missing SAMPLES definition
    SAMPLES = sorted({
    f.stem.rsplit("_", 1)[0]
    for f in Path("reads").glob("*_1.fq.gz")
})

- missing environmental modules
    envmodules:
        "fastp/0.24.0"
    envmodules:
        "multiqc"
-->